var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#PoGO.jl-exported-functions","page":"API Reference","title":"PoGO.jl exported functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"PoGO.approximate\nPoGO.interpolate\nPoGO.interpolate_fn\nPoGO.interpolate_points\nPoGO.plot_approximation\nPoGO.power","category":"page"},{"location":"api/#PoGO.approximate","page":"API Reference","title":"PoGO.approximate","text":"approximate(\n    x::Union{VariableRef,AffExpr},\n    func::Function,\n    n::Int = 0;\n    δ::Real = 0.0,\n    method::Symbol = :default,\n    type::Symbol = :interior,\n    knots::Union{Nothing,Vector{Float64},Vector{Tuple{Float64,Symbol}}} = nothing,\n    name::String = \"\",\n)\n\nFunction that defines a mixed-integer programming formulation for an arbitrary univariate function.\n\nRequired arguments\n\nx is either of type VariableRef or AffExpr and is the input variable for the function func.\n\nfunc is the function that we are approximating.\n\nOptional arguments\n\nn the number of points sampled between knots (ignored if δ is used).\n\nδ is the minimum distance between sample points.\n\nmethod is the method of the approximation. This can be set to :binary, :echelon, :convex, :bisection, :SOS1 or :SOS2.\n\ntype specifies how the approximation bounds the actual function. This can be set to :upper, :lower, :interior, tangent_cuts or :combined.\n\nknots must list the function's discontinuities, and points of inflection. Can be provided with curvature specifed, but if not this will be determined automatically.\n\nname can be set to give the variables created meaningful names.\n\n\n\n\n\n","category":"function"},{"location":"api/#PoGO.interpolate","page":"API Reference","title":"PoGO.interpolate","text":"interpolate(\n    x_vector::Vector{<:Union{VariableRef,AffExpr}},\n    points::Vector{<:Tuple},\n    sets::Vector;\n    update_bounds::Bool = false,\n    method::Symbol = :default,\n    name::String = \"\",\n)\n\nFunction that interpolates over a set of variables (or affine expressions). If the number of dimensions of the points vector exceeds the number of elements in the variables vector, then new variables are created and their values interpolated based on the other variables. If the dimensions of the points vector is the same as the number of variables then this enforces a constraint that the variables must lie inside the convex hull of one of the sets of points (defined by sets).\n\nRequired arguments\n\nx_vector vector of variables or expressions that will be used as the domain of the interpolation\n\npoints vector of points that define the interpolation; these points can contain real number and as well as variables and expressions.\n\nsets for each point in the vector points, sets contains the name(s) of the sets that point is a member of. \n\nOptional arguments\n\nupdate_bounds is set to true if the upper and lower bounds of x_vector components should be updated based on the values in points.\n\nmethod if the formulation method and can be set to :convex, :SOS1, :binary or :bisection.\n\nname can be set to give the variables created meaningful names.\n\n\n\n\n\n","category":"function"},{"location":"api/#PoGO.interpolate_fn","page":"API Reference","title":"PoGO.interpolate_fn","text":"interpolate_fn(\n    f::Function,\n    x_vector::Vector{<:Union{VariableRef,AffExpr}},\n    grid::Vector{<:Union{AbstractRange,Vector{<:Real}}};\n    method::Symbol = :default,\n)\n\nFunction that interpolates a function f over a set of variables (or affine expressions). The grid vector should be the same length as the x_vector. \n\nRequired arguments\n\nf a possibly multidimensional function that takes a vector of arguments the same length as x_vector.\n\nx_vector a vector of variables or expressions that are the input vector for f.\n\ngrid is a vector of ranges or vectors that specify the sample points (which are the Cartesian product of the vectors) for the function f.\n\nOptional arguments\n\nmethod if the formulation method and can be set to :convex, :SOS1, :binary or :bisection.\n\n\n\n\n\ninterpolate_fn(\n    f::Function,\n    x_vector::Vector{<:Union{VariableRef,AffExpr}},\n    points::T where {T<:Matrix};\n    method::Symbol = :default,\n)\n\nFunction that interpolates a function f over a set of variables (or affine expressions). The number of columns of the points matrix should be the same as the length of the x_vector. \n\nRequired arguments\n\nf a possibly multidimensional function that takes a vector of arguments the same length as x_vector.\n\nx_vector a vector of variables or expressions that are the input vector for f.\n\npoints is a Matrix that specifies the sample points for the function.\n\nOptional arguments\n\nmethod if the formulation method and can be set to :convex, :SOS1, :binary or :bisection.\n\n\n\n\n\n","category":"function"},{"location":"api/#PoGO.interpolate_points","page":"API Reference","title":"PoGO.interpolate_points","text":"interpolate_points(\n    x_vector::Vector{<:Union{VariableRef,AffExpr}},\n    points::T where {T<:Matrix};\n    method::Symbol = :default,\n)\n\nFunction that interpolates over a set of variables (or affine expressions). The number of columns of the points matrix should be greater than or equal to the length of the x_vector. For any extra columns, new variables will be defined, and their values will be interpolated. \n\nRequired arguments\n\nx_vector a vector of variables or expressions around which the triangulation will be formed.\n\npoints is a Matrix that specifies the points to be interpolated.\n\nOptional arguments\n\nmethod if the formulation method and can be set to :convex, :SOS1, :binary or :bisection.\n\n\n\n\n\n","category":"function"},{"location":"api/#PoGO.plot_approximation","page":"API Reference","title":"PoGO.plot_approximation","text":"plot_approximation(\n    optimizer,\n    func::Function,\n    lb::Real,\n    ub::Real,\n    δ::Real,\n    type::Symbol;\n    detail::Int = 3,\n    knots::Union{Nothing,Vector{Float64},Vector{Tuple{Float64,Symbol}}} = nothing,\n)\n\nFunction that returns a set of points corresponding to an approximation of the function func.\n\n\n\n\n\n","category":"function"},{"location":"api/#PoGO.power","page":"API Reference","title":"PoGO.power","text":"power(\n    x::Union{VariableRef,AffExpr},\n    y::Union{VariableRef,AffExpr},\n    n::Int = 0;\n    method::Symbol = :default,\n    type::Symbol = :interior,\n    name::String = \"\",\n)\n\nFunction that defines a power formulation (x^y) for a given pair of variables or affine expressions. This function will select the best formulation, given x and y.\n\nRequired arguments\n\nx and y are either of type VariableRef or AffExpr and x^y is the power function that is being modelled.\n\nOptional arguments\n\nn is used if the power is approximated using the difference of two squares.\n\nmethod is used if the power is approximated using the difference of two squares. This can be set to :binary :echelon :SOS1 or :SOS2.\n\ntype is used if the power is approximated using the difference of two squares. This can be set to :upper :lower :interior cutting_planes or :combined.\n\nname can be set to give the variables created meaningful names.\n\n\n\n\n\n","category":"function"},{"location":"api/#PoGO.jl-internal-functions","page":"API Reference","title":"PoGO.jl internal functions","text":"","category":"section"},{"location":"api/","page":"API Reference","title":"API Reference","text":"PoGO.one_binary_bilinear_formulation\nPoGO.discrete_bilinear_formulation\nPoGO.find_bounds\nPoGO.find_points\nPoGO.get_model\nPoGO.get_type\nPoGO.infer_curvature\nPoGO.process_knots\nPoGO.setup_parametric_model","category":"page"},{"location":"api/#PoGO.one_binary_bilinear_formulation","page":"API Reference","title":"PoGO.one_binary_bilinear_formulation","text":"one_binary_bilinear_formulation(\n    model::JuMP.Model,\n    xy::VariableRef,\n    x::Union{VariableRef,AffExpr},\n    y::Union{VariableRef,AffExpr},\n)\n\nInternal function that defines a bilinear formulation when one of the variables is binary.\n\n\n\n\n\n","category":"function"},{"location":"api/#PoGO.discrete_bilinear_formulation","page":"API Reference","title":"PoGO.discrete_bilinear_formulation","text":"discrete_bilinear_formulation(\n    model::JuMP.Model,\n    xy::VariableRef,\n    x::Union{VariableRef,AffExpr},\n    y::Union{VariableRef,AffExpr},\n    x_values::Vector,\n    mx::Float64,\n    mn::Float64,\n)\n\nInternal function that defines a bilinear formulation when one of the variables is discrete.\n\n\n\n\n\n","category":"function"},{"location":"api/#PoGO.find_bounds","page":"API Reference","title":"PoGO.find_bounds","text":"findbounds(x::Union{VariableRef,AffExpr}; ignoreerrors = false)\n\nInternal function that finds the upper and lower bounds of a variable or affine expression. ignore_errors can be set to true if we are happy to get Inf or -Inf if the bounds are not defined.\n\n\n\n\n\n","category":"function"},{"location":"api/#PoGO.find_points","page":"API Reference","title":"PoGO.find_points","text":"find_points(\n    func::Function,\n    n::Integer,\n    δ::Real,\n    knots::Vector{Float64},\n    knots_shape::Vector{Symbol},\n    type::Symbol,\n)\n\nInternal function that finds all the points and corresponding function values, given knots and the sampling rate.\n\n\n\n\n\n","category":"function"},{"location":"api/#PoGO.get_model","page":"API Reference","title":"PoGO.get_model","text":"get_model(x::Union{VariableRef,AffExpr})\n\nInternal function that gets the model associated with a variable or affine expression.\n\n\n\n\n\n","category":"function"},{"location":"api/#PoGO.get_type","page":"API Reference","title":"PoGO.get_type","text":"get_type(x::Union{VariableRef,AffExpr})\n\nInternal function that gets the type of a variable or affine expression. This can be :binary, :integer, :continuous or :discrete.\n\n\n\n\n\n","category":"function"},{"location":"api/#PoGO.infer_curvature","page":"API Reference","title":"PoGO.infer_curvature","text":"infer_curvature(\n    f::Function,\n    knots::Union{Nothing,Vector{Float64},Vector{Tuple{Float64,Symbol}}},\n    lx::Real,\n    ux::Real,\n)\n\nInternal function that uses automatic differentiation to infer the curvature of the function f between the bounds and the knots.\n\n\n\n\n\n","category":"function"},{"location":"api/#PoGO.process_knots","page":"API Reference","title":"PoGO.process_knots","text":"process_knots(\n    knots::Vector{Tuple{Float64,Symbol}},\n    lx::Real,\n    ux::Real,\n)::Tuple{Vector{Float64},Vector{Symbol}}\n\nInternal function that trims or extends the knots, given the lower and upper bounds.\n\n\n\n\n\n","category":"function"},{"location":"api/#PoGO.setup_parametric_model","page":"API Reference","title":"PoGO.setup_parametric_model","text":"setup_parametric_model(\n    optimizer,\n    func::Function,\n    knots::Union{Nothing,Vector{Float64},Vector{Tuple{Float64,Symbol}}},\n    lb::Real,\n    ub::Real,\n    δ::Real,\n    type::Symbol,\n)\n\nInternal function that creates a simple JuMP.Model to evaluate an interpolated function.\n\n\n\n\n\n","category":"function"},{"location":"","page":"PoGO.jl","title":"PoGO.jl","text":"CurrentModule = PoGO\nDocTestSetup = quote\n    using PoGO\nend","category":"page"},{"location":"#PoGO.jl","page":"PoGO.jl","title":"PoGO.jl","text":"","category":"section"},{"location":"","page":"PoGO.jl","title":"PoGO.jl","text":"You can install PoGO by typing ] add PoGO.","category":"page"}]
}
